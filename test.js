// Generated by LiveScript 1.3.1
var fs, path, region, nbt, map, Promise, verify, box, wireframe, fill, set, patch, singlePatch;
fs = require('fs');
path = require('path');
region = require('./region');
nbt = require('./nbt');
map = require('./map');
Promise = require('bluebird');
verify = function(){
  console.log("verifying...");
  return map.read("/Users/tkirby/workspace/zbryikt/minecraft/out").then(function(regions){
    var i$, z, lresult$, j$, x, chunk, results$ = [];
    console.log("traversing...");
    for (i$ = 0; i$ <= 31; ++i$) {
      z = i$;
      lresult$ = [];
      for (j$ = 0; j$ <= 31; ++j$) {
        x = j$;
        chunk = regions[0][0].chunks[z][x];
        if (!chunk) {
          continue;
        }
        lresult$.push(nbt.traverse(chunk));
      }
      results$.push(lresult$);
    }
    return results$;
  });
};
box = function(map, x, y, z, wx, wy, wz, id){
  var dv, i$, i, j$, step$, to$, cx, k$, step1$, to1$, cy, l$, step2$, to2$, cz, results$ = [];
  dv = [[1, 1, 1], [wx - 1, wy - 1, wz - 1]];
  for (i$ = 0; i$ <= 2; ++i$) {
    i = i$;
    dv[0][i] = dv[1][i];
    for (j$ = x, to$ = x + wx, step$ = dv[0][0] || 1; step$ < 0 ? j$ > to$ : j$ < to$; j$ += step$) {
      cx = j$;
      for (k$ = y, to1$ = y + wy, step1$ = dv[0][1] || 1; step1$ < 0 ? k$ > to1$ : k$ < to1$; k$ += step1$) {
        cy = k$;
        for (l$ = z, to2$ = z + wz, step2$ = dv[0][2] || 1; step2$ < 0 ? l$ > to2$ : l$ < to2$; l$ += step2$) {
          cz = l$;
          set(map, cx, cy, cz, id);
        }
      }
    }
    results$.push(dv[0][i] = 1);
  }
  return results$;
};
wireframe = function(map, x, y, z, wx, wy, wz, id){
  var dv, i$, i, j$, step$, to$, cx, k$, step1$, to1$, cy, l$, step2$, to2$, cz, results$ = [];
  dv = [[wx - 1, wy - 1, wz - 1], [wx - 1, wy - 1, wz - 1]];
  for (i$ = 0; i$ <= 2; ++i$) {
    i = i$;
    dv[0][i] = 1;
    for (j$ = x, to$ = x + wx, step$ = dv[0][0] || 1; step$ < 0 ? j$ > to$ : j$ < to$; j$ += step$) {
      cx = j$;
      for (k$ = y, to1$ = y + wy, step1$ = dv[0][1] || 1; step1$ < 0 ? k$ > to1$ : k$ < to1$; k$ += step1$) {
        cy = k$;
        for (l$ = z, to2$ = z + wz, step2$ = dv[0][2] || 1; step2$ < 0 ? l$ > to2$ : l$ < to2$; l$ += step2$) {
          cz = l$;
          set(map, cx, cy, cz, id);
        }
      }
    }
    results$.push(dv[0][i] = dv[1][i]);
  }
  return results$;
};
fill = function(map, x, y, z, wx, wy, wz, id){
  var i$, to$, cx, lresult$, j$, to1$, cy, lresult1$, k$, to2$, cz, results$ = [];
  for (i$ = x, to$ = x + wx; i$ < to$; ++i$) {
    cx = i$;
    lresult$ = [];
    for (j$ = y, to1$ = y + wy; j$ < to1$; ++j$) {
      cy = j$;
      lresult1$ = [];
      for (k$ = z, to2$ = z + wz; k$ < to2$; ++k$) {
        cz = k$;
        lresult1$.push(set(map, cx, cy, cz, id));
      }
      lresult$.push(lresult1$);
    }
    results$.push(lresult$);
  }
  return results$;
};
set = function(map, x, y, z, id){
  var ref$, cx, cy, cz, rx, rz, dx, dy, dz, region, chunk, sections, i$, len$, s, Y, ns, j$, k$;
  ref$ = [x / 16, y / 16, z / 16].map(function(it){
    return parseInt(it);
  }), cx = ref$[0], cy = ref$[1], cz = ref$[2];
  ref$ = [cx / 32, cz / 32].map(function(it){
    return parseInt(it);
  }), rx = ref$[0], rz = ref$[1];
  ref$ = [x, y, z].map(function(it){
    return it % 16;
  }), dx = ref$[0], dy = ref$[1], dz = ref$[2];
  region = map.regions[rx][rz];
  chunk = region.chunks[cz][cx];
  sections = chunk.data[""].value.Level.value.Sections.value;
  for (i$ = 0, len$ = sections.length; i$ < len$; ++i$) {
    s = sections[i$];
    Y = s.value.Y.value;
    if (Y === cy) {
      return s.value.Blocks.value[dy * 256 + dz * 16 + dx] = id;
    }
  }
  ns = clone$(sections[0]);
  ns.value.Y.value = cy;
  for (i$ = 0; i$ <= 15; ++i$) {
    dx = i$;
    for (j$ = 0; j$ <= 15; ++j$) {
      dy = j$;
      for (k$ = 0; k$ <= 15; ++k$) {
        dz = k$;
        ns.value.Blocks.value[dy * 256 + dz * 16 + dx] = 0;
      }
    }
  }
  return sections.push(ns);
};
patch = function(){
  console.log("reading original map...");
  return map.read("/Users/tkirby/workspace/zbryikt/minecraft/tests/").then(function(regions){
    console.log("patching map...");
    /*for cx from 0 to 31 => for cz from 0 to 31 =>
      chunk = regions[0][0].chunks[cz][cx]
      if !chunk or !chunk.data => continue
      sections = regions[0][0].chunks[cz][cx].data[""]value.Level.value.Sections.value
      [x,y,z] = [0,0,0]
      for s in sections =>
        console.log s
        console.log s.value.Y
        Y = s.value.Y.value
        for y from 0 to 15 => for x from 0 to 15 => for z from 0 to 15 => s.value.Blocks.value[y*256 + z*16 + x] = 0
        if Y <=3 => 
          for y from 0 to 15 => for x from 0 to 15 => for z from 0 to 15 => s.value.Blocks.value[y*256 + z*16 + x] = 56
        if Y == 4 =>
          for y from 0 to 7 => for x from 0 to 15 => for z from 0 to 15 =>
            s.value.Blocks.value[y * 256 + z * 16 + x] = if (x % 2) == 0 => 79 else 0
    */
    console.log("saving...");
    return map.write("/Users/tkirby/workspace/zbryikt/minecraft/out", regions).then(function(){
      return verify();
    });
  });
};
singlePatch = function(){
  console.log("read...");
  return region.read('tests/sample.mca').then(function(r){
    var regions, m;
    console.log("ok. patching...");
    regions = {
      0: {
        0: (r.x = 0, r.z = 0, r)
      }
    };
    m = {
      regions: regions
    };
    wireframe(m, 1, 99, 1, 10, 6, 10, 17);
    fill(m, 1, 89, 1, 10, 10, 10, 20);
    box(m, 1, 99, 1, 10, 1, 10, 17);
    box(m, 1, 104, 1, 10, 1, 10, 17);
    box(m, 2, 100, 1, 8, 4, 1, 20);
    box(m, 2, 100, 10, 8, 4, 1, 20);
    box(m, 1, 100, 2, 1, 4, 8, 20);
    box(m, 10, 100, 2, 1, 4, 8, 20);
    console.log("patched.");
    return map.write("/Users/tkirby/workspace/zbryikt/minecraft/out", regions).then(function(){
      return console.log('done');
    });
  });
};
singlePatch();
function clone$(it){
  function fun(){} fun.prototype = it;
  return new fun;
}