// Generated by LiveScript 1.3.1
var fs, zlib, ref$, b2v, b2u, u2b, b2i64, makebuf, nbt;
fs = require('fs');
zlib = require('zlib');
ref$ = require('./util'), b2v = ref$.b2v, b2u = ref$.b2u, u2b = ref$.u2b, b2i64 = ref$.b2i64, makebuf = ref$.makebuf;
nbt = {
  traverse: function(chunk){
    var k, ref$, v, results$ = [];
    for (k in ref$ = chunk.data) {
      v = ref$[k];
      results$.push(this._traverse(k, v, 0));
    }
    return results$;
  },
  _traverse: function(name, v, lv){
    var str, k, ref$, results$ = [];
    str = "";
    if (v.type < 7) {
      str = v.value;
    } else if (v.type === 7) {
      str = "Byte Array (" + v.value.length + ")";
    } else if (v.type === 8) {
      str = "[" + v.value + "]";
    } else if (v.type === 9) {
      str = "List (" + (v.value.length ? "Type " + v.value[0].type + " x " + v.value.length : "empty") + ")";
    } else if (v.type === 11) {
      str = "Int Array  (" + v.value.length + ")";
    }
    console.log(repeatString$('  ', lv) + "" + repeatString$(' ', v.type > 9 ? 0 : 1) + v.type + " [" + name + "]" + repeatString$(' ', 20 - name.length) + str);
    if (v.type === 9 && v.value.length > 0 && v.value[0].type === 10) {
      return this._traverse(name + "[0]", v.value[0], lv + 1);
    } else if (v.type === 10) {
      for (k in ref$ = v.value) {
        v = ref$[k];
        results$.push(this._traverse(k, v, lv + 1));
      }
      return results$;
    }
  },
  encode: function(data){
    var size, k, v, buf, offset, delta, nbuf, i$, i;
    size = (function(){
      var ref$, results$ = [];
      for (k in ref$ = data) {
        v = ref$[k];
        results$.push(this.size(k, v));
      }
      return results$;
    }.call(this)).reduce(function(a, b){
      return a + b;
    }, 0);
    buf = new Buffer(size);
    offset = 0;
    for (k in data) {
      v = data[k];
      delta = this._encode(k, v, buf, offset);
      offset += delta;
    }
    buf[offset] = 0;
    nbuf = new Buffer(offset);
    for (i$ = 0; i$ < offset; ++i$) {
      i = i$;
      nbuf[i] = buf[i];
    }
    return nbuf;
  },
  _encode: function(name, arg$, buf, offset, tag){
    var type, value, delta, i$, to$, i, len, delta2, len$, item, k, v;
    type = arg$.type, value = arg$.value;
    tag == null && (tag = true);
    delta = 0;
    if (tag) {
      delta = this.encodeTag(name, {
        type: type,
        value: value
      }, buf, offset);
    }
    offset += delta;
    if (type === 0) {
      return delta;
    }
    if (type === 1) {
      buf.writeInt8(value, offset);
      return delta + 1;
    }
    if (type === 2) {
      buf.writeInt16BE(value, offset);
      return delta + 2;
    }
    if (type === 3) {
      buf.writeInt32BE(value, offset);
      return delta + 4;
    }
    if (type === 4) {
      buf.writeUInt32BE(value[0], offset);
      buf.writeUInt32BE(value[1], offset + 4);
      return delta + 8;
    }
    if (type === 5) {
      buf.writeFloatBE(value, offset);
      return delta + 4;
    }
    if (type === 6) {
      buf.writeDoubleBE(value, offset);
      return delta + 8;
    }
    if (type === 7) {
      buf.writeInt32BE(value.length, offset);
      for (i$ = 0, to$ = value.length; i$ < to$; ++i$) {
        i = i$;
        buf[offset + 4 + i] = value[i];
      }
      return delta + 4 + value.length;
    }
    if (type === 8) {
      len = buf.write(value, offset + 2, value.length, 'utf-8');
      buf.writeInt16BE(len, offset);
      return delta + len + 2;
    }
    if (type === 9) {
      if (value.length === 0) {
        buf.writeInt8(0, offset);
      } else {
        buf.writeInt8(value[0].type, offset);
      }
      buf.writeInt32BE(value.length, offset + 1);
      delta2 = 0;
      for (i$ = 0, len$ = value.length; i$ < len$; ++i$) {
        item = value[i$];
        delta2 += this._encode(null, item, buf, offset + 5 + delta2, false);
      }
      return delta + 1 + 4 + delta2;
    }
    if (type === 10) {
      delta2 = 0;
      for (k in value) {
        v = value[k];
        delta2 += this._encode(k, v, buf, offset + delta2);
      }
      buf.writeInt8(0, offset + delta2);
      return delta + delta2 + 1;
    }
    if (type === 11) {
      buf.writeInt32BE(value.length, offset);
      for (i$ = 0, to$ = value.length; i$ < to$; ++i$) {
        i = i$;
        buf.writeInt32BE(value[i], offset + i * 4 + 4);
      }
      return delta + 4 + value.length * 4;
    }
    return 0;
  },
  encodeTag: function(name, arg$, buf, offset){
    var type, value, delta;
    type = arg$.type, value = arg$.value;
    buf.writeUInt8(type, offset);
    if (type === 0) {
      return 1;
    }
    buf.writeUInt16BE(name.length, offset + 1);
    delta = buf.write(name, offset + 3, name.length, 'utf-8');
    return delta + 3;
  },
  size: function(name, arg$){
    var type, value, len, v, n;
    type = arg$.type, value = arg$.value;
    len = type < 7
      ? [0, 1, 2, 4, 8, 4, 8][type]
      : type === 7
        ? 4 + value.length
        : type === 8
          ? 2 + u2b(value).length
          : type === 9
            ? 1 + 4 + (function(){
              var i$, ref$, len$, results$ = [];
              for (i$ = 0, len$ = (ref$ = value).length; i$ < len$; ++i$) {
                v = ref$[i$];
                results$.push(this.size(null, v));
              }
              return results$;
            }.call(this)).reduce(function(a, b){
              return a + b;
            }, 0)
            : type === 10
              ? (function(){
                var results$ = [];
                for (n in value) {
                  results$.push(3 + this.size(n, value[n]));
                }
                return results$;
              }.call(this)).reduce(function(a, b){
                return a + b;
              }, 0) + 1
              : type === 11 ? 4 + 4 * value.length : 0;
    if (name !== null) {
      len += 3 + u2b(name).length;
    }
    return len;
  },
  parse: function(data, offset){
    var ret;
    offset == null && (offset = 0);
    ret = this.compound(data, offset, data.length);
    return ret[1];
  },
  tag: function(data, offset){
    var type, length, name;
    type = data[offset];
    if (type === 0) {
      return [
        1, {
          type: type,
          name: ""
        }
      ];
    }
    length = b2v(data, offset + 1, 2);
    name = b2u(data, offset + 3, length);
    return [
      1 + 2 + length, {
        type: type,
        name: name
      }
    ];
  },
  compound: function(data, offset, limit){
    var ret, delta, ref$, d1, t, d2, v;
    limit == null && (limit = 0);
    ret = {};
    delta = 0;
    for (;;) {
      if (limit && delta >= limit) {
        return [delta, ret];
      }
      ref$ = this.tag(data, offset + delta), d1 = ref$[0], t = ref$[1];
      delta += d1;
      if (t.type === 0) {
        return [delta, ret];
      }
      ref$ = this.data(data, offset + delta, t), d2 = ref$[0], v = ref$[1];
      delta += d2;
      ret[t.name] = {
        type: t.type,
        value: v
      };
    }
  },
  data: function(data, offset, tag){
    var len, ret, tagid, ptr, i$, i, ref$, delta, value, subtype;
    if (tag.type < 7) {
      return (function(){
        switch (tag.type) {
        case 0:
          return [0, 0];
        case 1:
          return [1, data[offset]];
        case 2:
          return [2, data.readInt16BE(offset)];
        case 3:
          return [4, data.readInt32BE(offset)];
        case 4:
          return [8, [data.readUInt32BE(offset), data.readUInt32BE(offset + 4)]];
        case 5:
          return [4, data.readFloatBE(offset)];
        case 6:
          return [8, data.readDoubleBE(offset)];
        }
      }());
    }
    if (tag.type === 7) {
      len = b2v(data, offset, 4);
      ret = makebuf(data, offset + 4, len);
      return [len + 4, ret];
    }
    if (tag.type === 8) {
      len = b2v(data, offset, 2);
      ret = b2u(data, offset + 2, len);
      return [len + 2, ret];
    }
    if (tag.type === 9) {
      tagid = b2v(data, offset, 1);
      len = b2v(data, offset + 1, 4);
      ret = [];
      ptr = 5;
      for (i$ = 0; i$ < len; ++i$) {
        i = i$;
        ref$ = this.data(data, offset + ptr, {
          type: tagid
        }), delta = ref$[0], value = ref$[1], subtype = ref$[2];
        ret = ret.concat([{
          type: tagid,
          value: value
        }]);
        ptr += delta;
      }
      return [ptr, ret, tagid];
    }
    if (tag.type === 10) {
      return this.compound(data, offset);
    }
    if (tag.type === 11) {
      len = b2v(data, offset, 4);
      ret = new Array(len);
      for (i$ = 0; i$ < len; ++i$) {
        i = i$;
        ret[i] = b2v(data, offset + 4 + i * 4, 4);
      }
      return [len * 4 + 4, ret];
    }
  }
};
module.exports = nbt;
function repeatString$(str, n){
  for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
  return r;
}